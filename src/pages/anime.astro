---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// --- Bangumi API é…ç½® ---
const uid = "ferxal987";
const token = 'xQdjiPq4RSSym22QI92MVECwBHSFm5VV4Vpr9kdA';
const base = 'https://api.bgm.tv/v0';

// è¿™ä¸ªå‡½æ•°å·²è¢«fetchLatestEpisodeæ›¿ä»£

// --- ç±»å‹å®šä¹‰ ---
type Cat = 'watching' | 'wish' | 'collect';
type CatNum = 3 | 1 | 2;

interface Image {
  large?: string;
  common?: string;
  medium?: string;
  small?: string;
  grid?: string;
}

interface Subject {
  id: number;
  type: number;
  name: string;
  name_cn: string;
  eps?: number;
  images?: Image;
}

// æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¾§è¾¹æ æ¨¡å¼
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// Bangumi APIé…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id"; // ç”¨æˆ·ID
const BANGUMI_API_BASE = "https://api.bgm.tv";

interface CollectionResponse {
  data: CollectionItem[];
  limit: number;
  offset: number;
  total: number;
}

const cats = [
  { key: 'watching', name: 'åœ¨çœ‹', type: 3 },
  { key: 'wish',     name: 'æƒ³çœ‹', type: 1 },
  { key: 'collect',  name: 'çœ‹å®Œ', type: 2 },
];

// --- æ•°æ®è·å– ---
async function fetchOnce(type: CatNum): Promise<CollectionItem[]> {
  try {
    const res = await fetch(
      `${base}/users/${uid}/collections?subject_type=2&type=${type}&limit=50`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`API Error (${type}):`, res.status, await res.text());
      return [];
    }

    const json: CollectionResponse = await res.json();
    return Array.isArray(json.data) ? json.data : [];
  } catch (err) {
    console.error('Fetch error:', err);
    return [];
  }
}

// è·å–å•ä¸ªç•ªå‰§çš„è¯¦ç»†ä¿¡æ¯
async function fetchSubjectDetails(id: number): Promise<any> {
  try {
    const res = await fetch(`${base}/subjects/${id}`, {
      headers: { Authorization: `Bearer ${token}` }
    });

    if (!res.ok) {
      console.error(`Subject API Error (${id}):`, res.status, await res.text());
      return null;
    }

    const data = await res.json();
    return data;
  } catch (err) {
    console.error('Subject fetch error:', err);
    return null;
  }
}

// è·å–ç•ªå‰§çš„æœ€æ–°æ›´æ–°é›†æ•°å’Œæ›´æ–°æ—¶é—´
async function fetchLatestEpisode(id: number, watched: number): Promise<{latestEp: number, updateTime: string}> {
  try {
    // æ ¹æ®å·²çœ‹é›†æ•°è®¡ç®—offsetï¼Œä½†ç¡®ä¿ä¸è¶…è¿‡APIé™åˆ¶
    // APIé”™è¯¯æ˜¾ç¤ºoffsetä¸èƒ½è¶…è¿‡10ï¼Œæ‰€ä»¥æˆ‘ä»¬é™åˆ¶æœ€å¤§å€¼ä¸º10
    const offset = Math.min(10, Math.max(0, watched - 1));
    const res = await fetch(
      `${base}/episodes?subject_id=${id}&type=0&limit=50&offset=${offset}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`Episodes API Error (${id}):`, res.status, await res.text());
      return { latestEp: 0, updateTime: '' };
    }

    const data = await res.json();
    if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
      return { latestEp: 0, updateTime: '' };
    }

    // æŸ¥æ‰¾æœ‰airdateä¸”æ—¥æœŸæœ€æ–°çš„ä¸€é›†
    const now = new Date();
    let latestEpisode = 0;
    let latestUpdateTime = '';
    
    for (const episode of data.data) {
      if (episode.airdate) {
        const airDate = new Date(episode.airdate);
        // åªè®¡ç®—å·²ç»æ’­å‡ºçš„é›†æ•°
        if (airDate <= now && episode.ep > latestEpisode) {
          latestEpisode = episode.ep;
          latestUpdateTime = episode.airdate; // ä¿å­˜æœ€æ–°æ›´æ–°æ—¶é—´
        }
      }
    }
    
    return { latestEp: latestEpisode, updateTime: latestUpdateTime };
  } catch (err) {
    console.error('Episodes fetch error:', err);
    return { latestEp: 0, updateTime: '' };
  }
}

let allDataFetched = true;
const data: Record<Cat, CollectionItem[]> = { watching: [], wish: [], collect: [] };

try {
  const results = await Promise.all(cats.map(({ type }) => fetchOnce(type)));
  cats.forEach(({ key }, i) => { data[key] = results[i]; });
  
  // å¹¶è¡Œè·å–æ‰€æœ‰ç•ªå‰§çš„è¯¦ç»†ä¿¡æ¯
      const allItems = cats.flatMap(cat => 
        data[cat.key].map(item => ({ item, category: cat.key }))
      );
      
      const detailedItems = await Promise.all(
        allItems.map(async ({ item, category }) => {
          const details = await fetchSubjectDetails(item.subject.id);
          let latestEpisode = 0;
          let updateTime = '';
          
          // è·å–æ‰€æœ‰ç•ªå‰§çš„æœ€æ–°æ›´æ–°é›†æ•°å’Œæ›´æ–°æ—¶é—´
          const { latestEp, updateTime: latestUpdateTime } = await fetchLatestEpisode(item.subject.id, item.ep_status || 0);
          latestEpisode = latestEp;
          updateTime = latestUpdateTime;
          
          if (details) {
            // ä¿ç•™åŸå§‹çš„ type å­—æ®µï¼ˆæ”¶è—çŠ¶æ€ï¼‰ï¼Œåªåˆå¹¶å…¶ä»–è¯¦ç»†ä¿¡æ¯
            const { type, ...restDetails } = details;
            return { 
              category,
              index: data[category].indexOf(item),
              updatedItem: { 
                ...item, 
                ...restDetails,
                latest_episode: latestEpisode, // æ·»åŠ æœ€æ–°æ›´æ–°é›†æ•°ä¿¡æ¯
                update_time: updateTime // æ·»åŠ æœ€æ–°æ›´æ–°æ—¶é—´
              }
            };
          }
          return null;
        })
      );
      
      // æ›´æ–°æ•°æ®
      detailedItems.filter(Boolean).forEach(({ category, index, updatedItem }) => {
        data[category][index] = updatedItem;
      });
} catch (err) {
  console.error("Fetch failed:", err);
  allDataFetched = false;
}

// å®šä¹‰é™æ€å‰¯æ ‡é¢˜æ•°ç»„
const subtitles = [

];

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬
function getStatusText(status: string): string {
	switch (status) {
		case "watching":
			return i18n(I18nKey.animeStatusWatching);
		case "completed":
			return i18n(I18nKey.animeStatusCompleted);
		default:
			return status;
	}
}

// è·å–Bangumiæ”¶è—åˆ—è¡¨
async function fetchBangumiCollection(
	userId: string,
	subjectType: number,
	type: number,
) {
	try {
		let allData: any[] = [];
		let offset = 0;
		const limit = 50; // æ¯é¡µè·å–çš„æ•°é‡
		let hasMore = true;

		// å¾ªç¯è·å–æ‰€æœ‰æ•°æ®
		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
			);
			if (!response.ok) {
				throw new Error(`Bangumi API error: ${response.status}`);
			}
			const data = await response.json();

			// æ·»åŠ å½“å‰é¡µæ•°æ®åˆ°æ€»æ•°æ®ä¸­
			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) {
				hasMore = false;
			} else {
				offset += limit;
			}
			// é˜²æ­¢è¯·æ±‚è¿‡äºé¢‘ç¹
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

// è·å–Bangumiæ•°æ®è½¬æ¢ä¸ºé¡µé¢æ‰€éœ€æ ¼å¼
async function processBangumiData(data: any, status: string) {
	if (!data || !data.data) return [];

	// ä¸ºæ¯ä¸ªæ¡ç›®è·å–è¯¦ç»†ä¿¡æ¯
	const detailedItems = await Promise.all(
		data.data.map(async (item: any) => {
			// è·å–ç›¸å…³äººå‘˜ä¿¡æ¯
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			// è·å–å¹´ä»½ä¿¡æ¯
			const year = item.subject?.date || "Unknown";
			// è·å–è¯„åˆ†
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			// è·å–è¿›åº¦ä¿¡æ¯
			const progress = item.ep_status || 0;
			const totalEpisodes = item.subject?.eps || progress;
			// ä»ç›¸å…³äººå‘˜ä¸­è·å–åˆ¶ä½œæ–¹ä¿¡æ¯
			let studio = "Unknown";
			if (Array.isArray(subjectPersons)) {
				// å®šä¹‰ç­›é€‰ä¼˜å…ˆçº§é¡ºåº
				const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
				for (const relation of priorities) {
					const match = subjectPersons.find(
						(person) => person.relation === relation,
					);
					if (match?.name) {
						studio = match.name;
						break;
					}
				}
			}

			return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
				status: status,
				rating: rating,
				cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (
					item.subject?.short_summary ||
					item.subject?.name_cn ||
					""
				).trimStart(),
				episodes: `${totalEpisodes} episodes`,
				year: year,
				genre: item.subject?.tags
					? item.subject.tags.slice(0, 3).map((tag: any) => tag.name)
					: ["Unknown"],
				studio: studio,
				link: item.subject?.id
					? `https://bgm.tv/subject/${item.subject.id}`
					: "#",
				progress: progress,
				totalEpisodes: totalEpisodes,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			};
		}),
	);
	return detailedItems;
}

// æ ¹æ®æ¨¡å¼è·å–ç•ªå‰§åˆ—è¡¨
let animeList: typeof localAnimeList = [];
if (ANIME_MODE === "local") {
	// ä½¿ç”¨æœ¬åœ°é…ç½®
	animeList = localAnimeList;
} else {
	// ä½¿ç”¨Bangumi APIï¼ˆé»˜è®¤æ¨¡å¼ï¼‰
	// è·å–ä¸å¤„ç†åœ¨çœ‹åˆ—è¡¨ï¼ˆtype=3ï¼‰æƒ³çœ‹åˆ—è¡¨ï¼ˆtype=1ï¼‰çœ‹è¿‡åˆ—è¡¨ï¼ˆtype=2ï¼‰æç½®åˆ—è¡¨ï¼ˆtype=4ï¼‰æŠ›å¼ƒåˆ—è¡¨ï¼ˆtype=5ï¼‰
	const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
	const plannedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 1);
	const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);
	const onHoldData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 4);
	const droppedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 5);

	const watchingList = watchingData
		? await processBangumiData(watchingData, "watching")
		: [];
	const plannedList = plannedData
		? await processBangumiData(plannedData, "planned")
		: [];
	const completedList = completedData
		? await processBangumiData(completedData, "completed")
		: [];
	const onHoldList = onHoldData
		? await processBangumiData(onHoldData, "onhold")
		: [];
	const droppedList = droppedData
		? await processBangumiData(droppedData, "dropped")
		: [];

	animeList = [
		...watchingList,
		...plannedList,
		...completedList,
		...onHoldList,
		...droppedList,
	];
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(type: number) {
	switch (type) {
		case 3: // watching
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100/[var(--status-watching-opacity)] text-green-700 dark:bg-green-900/[var(--status-watching-opacity)] dark:text-green-300 border border-green-700/[var(--status-border-opacity)] dark:border-green-300/[var(--status-border-opacity)]",

				icon: "â–¶",
			};
		case 2: // collect
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100/[var(--status-completed-opacity)] text-blue-700 dark:bg-blue-900/[var(--status-completed-opacity)] dark:text-blue-300 border border-blue-700/[var(--status-border-opacity)] dark:border-blue-300/[var(--status-border-opacity)]",

				icon: "âœ“",
			};
		case 1: // wish
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100/[var(--status-planned-opacity)] text-amber-700 dark:bg-amber-900/[var(--status-planned-opacity)] dark:text-amber-300 border border-amber-700/[var(--status-border-opacity)] dark:border-amber-300/[var(--status-border-opacity)]",

				icon: "â°",
			};
		case "onhold":
			return {
				text: i18n(I18nKey.animeStatusOnHold),
				class:
					"bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
				icon: "â¸",
			};
		case "dropped":
			return {
				text: i18n(I18nKey.animeStatusDropped),
				class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
				icon: "âœ—",
			};
		default:
			return {
				text: "Unknown",
				class: "bg-gray-100/[var(--status-planned-opacity)] text-gray-700 dark:bg-gray-800/[var(--status-planned-opacity)] dark:text-gray-300 border border-gray-700/[var(--status-border-opacity)] dark:border-gray-300/[var(--status-border-opacity)]",

				icon: "?",
			};
	}
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
const stats = {
	total: data.watching.length + data.wish.length + data.collect.length,
	watching: data.watching.length,
	completed: data.collect.length
};
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>
        
        <!-- è¿‡æ»¤æŒ‰é’® - å‚è€ƒFireflyè®¾è®¡ -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">{i18n(I18nKey.animeFilterAll)}</button>
            <button class="filter-tag" data-status="watching">{i18n(I18nKey.animeStatusWatching)}</button>
            <button class="filter-tag" data-status="planned">{i18n(I18nKey.animeStatusPlanned)}</button>
            <button class="filter-tag" data-status="completed">{i18n(I18nKey.animeStatusCompleted)}</button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">{i18n(I18nKey.animeStatusOnHold)}</button>
                <button class="filter-tag" data-status="dropped">{i18n(I18nKey.animeStatusDropped)}</button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div class={`grid gap-4 md:gap-6 ${
            isBothSidebarMode 
              ? "grid-cols-2 md:grid-cols-3 lg:grid-cols-4" 
              : "grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5"
          }`}>
            {animeList.map(anime => {
              const statusInfo = getStatusInfo(anime.status);
              const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;
              
              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status={anime.status}>
                  <!-- å°é¢åŒºåŸŸ - ç«–å±æ¯”ä¾‹ -->
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={anime.cover} 
                        alt={anime.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- çŠ¶æ€æ ‡ç­¾ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- è¯„åˆ† -->
                    <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                      <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                      </svg>
                      <span>{anime.rating}</span>
                    </div>
                    
                    <!-- è¿›åº¦æ¡ - åœ¨å°é¢åº•éƒ¨ -->
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">
                          {anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <!-- å†…å®¹åŒºåŸŸ - ç´§å‡‘è®¾è®¡ -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    
                    <!-- è¯¦ç»†ä¿¡æ¯ - æ›´ç´§å‡‘ -->
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
                        <span class="text-black/70 dark:text-white/70">{anime.year}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {anime.genre.map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

<!-- å®¢æˆ·ç«¯äº¤äº’ -->
<script is:inline>
  // è®¡ç®—ç›¸å¯¹æ—¶é—´çš„å‡½æ•°
  function getRelativeTimeString(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);
    
    // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
    if (isNaN(date.getTime())) return '';
    
    // æ ¹æ®æ—¶é—´å·®è®¡ç®—ç›¸å¯¹æ—¶é—´
    if (seconds < 60) {
      return `${seconds}ç§’å‰`;
    }
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes}åˆ†é’Ÿå‰`;
    }
    
    const hours = Math.floor(minutes / 60);
    if (hours < 24) {
      return `${hours}å°æ—¶å‰`;
    }
    
    const days = Math.floor(hours / 24);
    if (days < 7) {
      return `${days}å¤©å‰`;
    }
    
    const months = Math.floor(days / 30);
    if (months < 12) {
      return `${months}ä¸ªæœˆå‰`;
    }
    
    /* åŠ¨ç”»å¡ç‰‡æ ·å¼ - ä½¿ç”¨ FLIP åŠ¨ç”»æŠ€æœ¯å®ç°æ´—ç‰Œæ•ˆæœ */
    [data-anime-status] {
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* å®Œå…¨éšè— */
    [data-anime-status].anime-hidden {
      display: none;
    }
    
    /* åŠ¨ç”»ä¸­çš„å¡ç‰‡ - ä½¿ç”¨ç»å¯¹å®šä½è¿›è¡Œä½ç½®è¿‡æ¸¡ */
    [data-anime-status].anime-animating {
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                  opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* æ·¡å‡ºæ•ˆæœï¼ˆç”¨äºè¦éšè—çš„å¡ç‰‡ï¼‰ - ç¼©å°å¹¶æ·¡å‡º */
    [data-anime-status].anime-fade-out {
      opacity: 0;
      transform: scale(0.8);
      pointer-events: none;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* æ·¡å…¥æ•ˆæœï¼ˆç”¨äºæ–°æ˜¾ç¤ºçš„å¡ç‰‡ï¼‰ - ä»å°æ”¾å¤§å¹¶æ·¡å…¥ */
    [data-anime-status].anime-fade-in {
      opacity: 0;
      transform: scale(0.8);
    }
    
    [data-anime-status].anime-fade-in-active {
      opacity: 1;
      transform: scale(1);
    }
  </style>

  <!-- è¿‡æ»¤åŠŸèƒ½è„šæœ¬ -->
  <script is:inline>
    // äº‹ä»¶ç›‘å¬å™¨å­˜å‚¨ï¼Œç”¨äºé˜²æ­¢é‡å¤ç»‘å®š
    let filterEventListeners = [];
    
    // åˆå§‹åŒ–è¿‡æ»¤åŠŸèƒ½
    function initFilterButtons() {
      const filterTags = document.querySelectorAll('.filter-tag');
      
      // ç§»é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
      filterEventListeners.forEach(listener => {
        const [element, type, handler] = listener;
        element.removeEventListener(type, handler);
      });
      filterEventListeners = [];
      
      // è¿‡æ»¤åŠŸèƒ½ - ä½¿ç”¨ FLIP æŠ€æœ¯å®ç°æ´—ç‰ŒåŠ¨ç”»
      filterTags.forEach(tag => {
        const clickHandler = function() {
          // é˜²æ­¢é‡å¤ç‚¹å‡»
          if (this.classList.contains('active')) return;
          
          // ç§»é™¤æ‰€æœ‰activeç±»
          filterTags.forEach(t => t.classList.remove('active'));
          // æ·»åŠ activeç±»åˆ°å½“å‰ç‚¹å‡»çš„æ ‡ç­¾
          this.classList.add('active');
          
          const status = this.getAttribute('data-status');
          const animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));
          
          // FLIP åŠ¨ç”»æŠ€æœ¯
          // First: è®°å½•æ‰€æœ‰å¡ç‰‡çš„åˆå§‹ä½ç½®
          const firstPositions = new Map();
          animeItems.forEach(item => {
            const rect = item.getBoundingClientRect();
            firstPositions.set(item, {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height
            });
          });
          
          // åˆ†ç±»å¡ç‰‡
          const itemsToHide = [];
          const itemsToShow = [];
          const itemsToKeep = [];
          
          animeItems.forEach(item => {
            const itemStatus = item.getAttribute('data-anime-status');
            const shouldShow = status === 'all' || itemStatus === status;
            const isCurrentlyVisible = !item.classList.contains('anime-hidden');
            
            if (shouldShow) {
              if (isCurrentlyVisible) {
                itemsToKeep.push(item);
              } else {
                itemsToShow.push(item);
              }
            } else {
              if (isCurrentlyVisible) {
                itemsToHide.push(item);
              }
            }
          });
          
          // ä¸ºè¦éšè—çš„å¡ç‰‡æ·»åŠ æ·¡å‡ºæ•ˆæœ
          itemsToHide.forEach(item => {
            item.classList.add('anime-fade-out');
          });
          
          // ç­‰å¾…æ·¡å‡ºå®Œæˆ
          setTimeout(() => {
            // Last: å®Œå…¨éšè—è¦ç§»é™¤çš„å¡ç‰‡
            itemsToHide.forEach(item => {
              item.classList.add('anime-hidden');
              item.classList.remove('anime-fade-out');
            });
            
            // æ˜¾ç¤ºæ–°å¡ç‰‡ä½†å…ˆè®¾ä¸ºé€æ˜å’Œç¼©å°ï¼ˆåœ¨å®ƒä»¬çš„æœ€ç»ˆä½ç½®ï¼‰
            itemsToShow.forEach(item => {
              item.classList.remove('anime-hidden');
              item.classList.add('anime-fade-in');
              item.style.opacity = '0';
              item.style.transform = 'scale(0.8)';
              item.style.transition = 'none';
            });
            
            // ç­‰å¾…å¸ƒå±€æ›´æ–°
            requestAnimationFrame(() => {
              // è®°å½•æ‰€æœ‰å¡ç‰‡çš„æœ€ç»ˆä½ç½®ï¼ˆåŒ…æ‹¬æ–°æ˜¾ç¤ºçš„å¡ç‰‡ï¼‰
              const lastPositions = new Map();
              [...itemsToKeep, ...itemsToShow].forEach(item => {
                const rect = item.getBoundingClientRect();
                lastPositions.set(item, {
                  left: rect.left,
                  top: rect.top
                });
              });
              
              // Invert: åªå¯¹ä¿æŒæ˜¾ç¤ºçš„å¡ç‰‡åº”ç”¨åå‘å˜æ¢
              itemsToKeep.forEach(item => {
                const first = firstPositions.get(item);
                const last = lastPositions.get(item);
                
                if (first && last) {
                  const deltaX = first.left - last.left;
                  const deltaY = first.top - last.top;
                  
                  // ç«‹å³åº”ç”¨åå‘å˜æ¢ï¼ˆä¸ä½¿ç”¨è¿‡æ¸¡ï¼‰
                  item.style.transition = 'none';
                  item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                }
              });
              
              // Play: è§¦å‘åŠ¨ç”»
              requestAnimationFrame(() => {
                const allItems = [...itemsToKeep, ...itemsToShow];
                
                allItems.forEach((item, index) => {
                  // é”™å¼€åŠ¨ç”»å¼€å§‹æ—¶é—´ï¼Œåˆ›å»ºæ³¢æµªæ•ˆæœ
                  setTimeout(() => {
                    item.classList.add('anime-animating');
                    
                    // ä¿æŒæ˜¾ç¤ºçš„å¡ç‰‡ï¼šç§»åŠ¨åˆ°æœ€ç»ˆä½ç½®
                    if (itemsToKeep.includes(item)) {
                      item.style.transition = '';
                      item.style.transform = '';
                    }
                    
                    // æ–°æ˜¾ç¤ºçš„å¡ç‰‡ï¼šåœ¨å½“å‰ä½ç½®æ·¡å…¥å¹¶æ”¾å¤§
                    if (itemsToShow.includes(item)) {
                      item.classList.remove('anime-fade-in');
                      item.classList.add('anime-fade-in-active');
                      item.style.transition = '';
                      item.style.opacity = '1';
                      item.style.transform = 'scale(1)';
                    }
                  }, index * 20); // æ¯ä¸ªå¡ç‰‡å»¶è¿Ÿ20ms
                });
                
                // åŠ¨ç”»å®Œæˆåæ¸…ç†
                setTimeout(() => {
                  allItems.forEach(item => {
                    item.classList.remove('anime-animating', 'anime-fade-in-active');
                    item.style.transition = '';
                    item.style.transform = '';
                    item.style.opacity = '';
                  });
                }, 500 + allItems.length * 20); // ç­‰å¾…æ‰€æœ‰åŠ¨ç”»å®Œæˆ
              });
            });
          }, 300); // ç­‰å¾…æ·¡å‡ºåŠ¨ç”»å®Œæˆ
        };
        
        tag.addEventListener('click', clickHandler);
        filterEventListeners.push([tag, 'click', clickHandler]);
      });
      
      console.log('Filter buttons initialized with', filterTags.length, 'buttons');
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', initFilterButtons);
    
    // Swupé¡µé¢åˆ‡æ¢åé‡æ–°åˆå§‹åŒ–
    function setupSwupListeners() {
      if (window.swup) {
        // ä½¿ç”¨Swup hooksç›‘å¬é¡µé¢åˆ‡æ¢äº‹ä»¶
        window.swup.hooks.on('content:replace', function() {
          console.log('Swup content replaced - reinitializing filter buttons');
          setTimeout(initFilterButtons, 150);
        });
        
        window.swup.hooks.on('page:view', function() {
          console.log('Swup page view - reinitializing filter buttons');
          setTimeout(initFilterButtons, 150);
        });
        
        window.swup.hooks.on('animation:in:end', function() {
          console.log('Swup animation ended - reinitializing filter buttons');
          setTimeout(initFilterButtons, 200);
        });
      }
    });
  }
  
  // åˆå§‹åŒ–å‡½æ•°
  function initPage() {
    // å›¾ç‰‡åŠ è½½å®Œæˆå¤„ç†
    document.querySelectorAll('.bangumi-img').forEach(img => {
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        img.addEventListener('load', function() {
          this.classList.add('loaded');
        });
      }
    }
  </script>
</MainGridLayout>
