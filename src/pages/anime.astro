---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// --- Bangumi API 配置 ---
const uid = "ferxal987";
const token = 'xQdjiPq4RSSym22QI92MVECwBHSFm5VV4Vpr9kdA';
const base = 'https://api.bgm.tv/v0';

// 这个函数已被fetchLatestEpisode替代

// --- 类型定义 ---
type Cat = 'watching' | 'wish' | 'collect';
type CatNum = 3 | 1 | 2;

interface Image {
  large?: string;
  common?: string;
  medium?: string;
  small?: string;
  grid?: string;
}

interface Subject {
  id: number;
  type: number;
  name: string;
  name_cn: string;
  eps?: number;
  images?: Image;
}

interface CollectionItem {
  subject_id: number;
  subject: Subject;
  ep_status: number;
  type: CatNum;
}

interface CollectionResponse {
  data: CollectionItem[];
  limit: number;
  offset: number;
  total: number;
}

const cats = [
  { key: 'watching', name: '在看', type: 3 },
  { key: 'wish',     name: '想看', type: 1 },
  { key: 'collect',  name: '看完', type: 2 },
];

// --- 数据获取 ---
async function fetchOnce(type: CatNum): Promise<CollectionItem[]> {
  try {
    const res = await fetch(
      `${base}/users/${uid}/collections?subject_type=2&type=${type}&limit=50`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`API Error (${type}):`, res.status, await res.text());
      return [];
    }

    const json: CollectionResponse = await res.json();
    return Array.isArray(json.data) ? json.data : [];
  } catch (err) {
    console.error('Fetch error:', err);
    return [];
  }
}

// 获取单个番剧的详细信息
async function fetchSubjectDetails(id: number): Promise<any> {
  try {
    const res = await fetch(`${base}/subjects/${id}`, {
      headers: { Authorization: `Bearer ${token}` }
    });

    if (!res.ok) {
      console.error(`Subject API Error (${id}):`, res.status, await res.text());
      return null;
    }

    const data = await res.json();
    return data;
  } catch (err) {
    console.error('Subject fetch error:', err);
    return null;
  }
}

// 获取番剧的最新更新集数和更新时间
async function fetchLatestEpisode(id: number, watched: number): Promise<{latestEp: number, updateTime: string}> {
  try {
    // 根据已看集数计算offset，但确保不超过API限制
    // API错误显示offset不能超过10，所以我们限制最大值为10
    const offset = Math.min(10, Math.max(0, watched - 1));
    const res = await fetch(
      `${base}/episodes?subject_id=${id}&type=0&limit=50&offset=${offset}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`Episodes API Error (${id}):`, res.status, await res.text());
      return { latestEp: 0, updateTime: '' };
    }

    const data = await res.json();
    if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
      return { latestEp: 0, updateTime: '' };
    }

    // 查找有airdate且日期最新的一集
    const now = new Date();
    let latestEpisode = 0;
    let latestUpdateTime = '';
    
    for (const episode of data.data) {
      if (episode.airdate) {
        const airDate = new Date(episode.airdate);
        // 只计算已经播出的集数
        if (airDate <= now && episode.ep > latestEpisode) {
          latestEpisode = episode.ep;
          latestUpdateTime = episode.airdate; // 保存最新更新时间
        }
      }
    }
    
    return { latestEp: latestEpisode, updateTime: latestUpdateTime };
  } catch (err) {
    console.error('Episodes fetch error:', err);
    return { latestEp: 0, updateTime: '' };
  }
}

let allDataFetched = true;
const data: Record<Cat, CollectionItem[]> = { watching: [], wish: [], collect: [] };

try {
  const results = await Promise.all(cats.map(({ type }) => fetchOnce(type)));
  cats.forEach(({ key }, i) => { data[key] = results[i]; });
  
  // 并行获取所有番剧的详细信息
      const allItems = cats.flatMap(cat => 
        data[cat.key].map(item => ({ item, category: cat.key }))
      );
      
      const detailedItems = await Promise.all(
        allItems.map(async ({ item, category }) => {
          const details = await fetchSubjectDetails(item.subject.id);
          let latestEpisode = 0;
          let updateTime = '';
          
          // 获取所有番剧的最新更新集数和更新时间
          const { latestEp, updateTime: latestUpdateTime } = await fetchLatestEpisode(item.subject.id, item.ep_status || 0);
          latestEpisode = latestEp;
          updateTime = latestUpdateTime;
          
          if (details) {
            // 保留原始的 type 字段（收藏状态），只合并其他详细信息
            const { type, ...restDetails } = details;
            return { 
              category,
              index: data[category].indexOf(item),
              updatedItem: { 
                ...item, 
                ...restDetails,
                latest_episode: latestEpisode, // 添加最新更新集数信息
                update_time: updateTime // 添加最新更新时间
              }
            };
          }
          return null;
        })
      );
      
      // 更新数据
      detailedItems.filter(Boolean).forEach(({ category, index, updatedItem }) => {
        data[category][index] = updatedItem;
      });
} catch (err) {
  console.error("Fetch failed:", err);
  allDataFetched = false;
}

// 定义静态副标题数组
const subtitles = [

];

// 获取状态的翻译文本
function getStatusText(status: string): string {
	switch (status) {
		case "watching":
			return i18n(I18nKey.animeStatusWatching);
		case "completed":
			return i18n(I18nKey.animeStatusCompleted);
		default:
			return status;
	}
}

// 图片处理函数 - 转换为webp并调整尺寸
function processImageUrl(url: string): string {
  if (!url || url.includes('/default-image.png')) return url;
  
  // 修改源图像URL，添加/r/400/前缀以减小图片尺寸
  const modifiedUrl = url.replace('https://lain.bgm.tv/', 'https://lain.bgm.tv/r/400/');
  
  // 使用图片CDN服务转换为WebP格式并调整尺寸
  return `https://images.weserv.nl/?url=${encodeURIComponent(modifiedUrl)}&w=300&h=400&output=webp`;
}

// 获取状态的翻译文本和样式
function getStatusInfo(type: number) {
	switch (type) {
		case 3: // watching
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100/[var(--status-watching-opacity)] text-green-700 dark:bg-green-900/[var(--status-watching-opacity)] dark:text-green-300 border border-green-700/[var(--status-border-opacity)] dark:border-green-300/[var(--status-border-opacity)]",

				icon: "▶",
			};
		case 2: // collect
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100/[var(--status-completed-opacity)] text-blue-700 dark:bg-blue-900/[var(--status-completed-opacity)] dark:text-blue-300 border border-blue-700/[var(--status-border-opacity)] dark:border-blue-300/[var(--status-border-opacity)]",

				icon: "✓",
			};
		case 1: // wish
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100/[var(--status-planned-opacity)] text-amber-700 dark:bg-amber-900/[var(--status-planned-opacity)] dark:text-amber-300 border border-amber-700/[var(--status-border-opacity)] dark:border-amber-300/[var(--status-border-opacity)]",

				icon: "⏰",
			};
		default:
			return {
				text: "Unknown",
				class: "bg-gray-100/[var(--status-planned-opacity)] text-gray-700 dark:bg-gray-800/[var(--status-planned-opacity)] dark:text-gray-300 border border-gray-700/[var(--status-border-opacity)] dark:border-gray-300/[var(--status-border-opacity)]",

				icon: "?",
			};
	}
}

// 计算统计数据
const stats = {
	total: data.watching.length + data.wish.length + data.collect.length,
	watching: data.watching.length,
	completed: data.collect.length
};
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
	<style is:global>
		:root {
			--status-planned-opacity: 0.3;
			--status-completed-opacity: 0.3;
			--status-watching-opacity: 0.3;
			--status-border-opacity: 0.15;
		}
	</style>
	<div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
		<div class="card-base z-10 px-9 py-6 relative w-full">
			<!-- 页面标题 -->
			<div class="relative w-full mb-8">
				<div class="mb-6">
					<h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2">{i18n(I18nKey.animeTitle)}</h1>
					<p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
				</div>
				
				<!-- 统计卡片 -->
				<div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-8">
					<div class="bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">📊</div>
							<div>
								<div class="text-2xl font-bold text-blue-600 dark:text-blue-400">{stats.total}</div>
								<div class="text-sm text-blue-600/70 dark:text-blue-400/70">{i18n(I18nKey.animeTotal)}</div>
							</div>
						</div>
					</div>
					<div class="bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900/20 dark:to-green-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">▶️</div>
							<div>
								<div class="text-2xl font-bold text-green-600 dark:text-green-400">{stats.watching}</div>
								<div class="text-sm text-green-600/70 dark:text-green-400/70">{i18n(I18nKey.animeWatching)}</div>
							</div>
						</div>
					</div>
					<div class="bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">✅</div>
							<div>
								<div class="text-2xl font-bold text-purple-600 dark:text-purple-400">{stats.completed}</div>
								<div class="text-sm text-purple-600/70 dark:text-purple-400/70">{i18n(I18nKey.animeCompleted)}</div>
							</div>
						</div>
					</div>
					
				</div>
			</div>

			<!-- 动漫列表 -->
				<div class="mb-8">
				<h2 class="text-2xl font-bold text-black/90 dark:text-white/90 mb-4">
					{i18n(I18nKey.animeList)}
				</h2>
				{allDataFetched ? (
				<div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
					{[...data.watching, ...data.wish, ...data.collect].map((item, index) => {
							const s = item.subject || item;
							const total = s.eps || 0;
							const watched = item.ep_status || 0;
							const percent = total ? Math.min(100, Math.round((watched / total) * 100)) : 0;
							const img = processImageUrl(s.images?.large || s.images?.common || '/default-image.png');
							const statusInfo = getStatusInfo(item.type);
							
							return (
								<div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]">
									<!-- 封面区域 - 竖屏比例 -->
									<div class="relative aspect-[2/3] overflow-hidden">
										<a href={`https://bgm.tv/subject/${s.id}`} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
											<ImageWrapper 
												src={img}
												alt={s.name_cn || s.name || '未知'}
												class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
												data-src-fallback="/default-image.png"
												id={`anime-img-${s.id}`}
											/>
											<!-- 悬停效果已移除，仅保留链接功能 -->
										</a>
										
										<!-- 状态标签 -->
										<div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
											<span class="mr-1">{statusInfo.icon}</span>
											<span>{statusInfo.text}</span>
										</div>
										
										<!-- 评分 -->
										<div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
											<svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
												<path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
											</svg>
											<span>{s.rating?.score || s.score || '0.0'}</span>
										</div>
										
										<!-- 进度条 - 在封面底部 -->
										{item.type === 3 && (
											<div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
												<div class="w-full bg-white/20 rounded-full h-1.5 mb-1 relative">
													{/* 已更新进度条 */}
													{item.latest_episode > 0 && (
														<div class="bg-gradient-to-r from-amber-400 to-orange-400 h-1.5 rounded-full absolute top-0 left-0 transition-all duration-300" 
															style={`width: ${Math.min(100, Math.round((item.latest_episode / total) * 100))}%`}>
														</div>
													)}
													{/* 已看进度条 */}
													<div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300 relative z-10" 
														style={`width: ${percent}%`}>
													</div>
												</div>
												<div class="text-white text-xs font-medium flex justify-between">
													<span>{watched}/{total} ({Math.round(percent)}%)</span>
													{item.latest_episode > watched && (
														<span class="text-amber-300">已更新至: 第{item.latest_episode}集</span>
													)}
												</div>
											</div>
										)}
									</div>
									
									<!-- 内容区域 - 紧凑设计 -->
									<div class="p-3">
										<h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{s.name_cn || s.name}</h3>
										
										{/* 更新状态信息 */}
										{item.type === 3 && item.latest_episode > 0 && (
											<p class="text-xs mb-2">
												{item.latest_episode > item.ep_status ? (
													<span class="text-amber-500 dark:text-amber-400 font-medium">🔔 未看 {item.latest_episode - item.ep_status} 集</span>
												) : (
													<span class="text-green-500 dark:text-green-400 font-medium">✓ 已看最新</span>
												)}
											</p>
										)}
										
										<p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{subtitles[index % subtitles.length]}</p>
									
									<!-- 详细信息 - 更紧凑 -->
									<div class="space-y-1 text-xs">
										<div class="flex justify-between">
											<span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
											<span class="text-black/70 dark:text-white/70">{s.date}</span>
										</div>
										
										{/* 最近更新时间 */}
									{item.update_time && (
										<div class="flex justify-between">
											<span class="text-black/50 dark:text-white/50">最近更新</span>
											<span class="text-black/70 dark:text-white/70" data-update-time={item.update_time}></span>
										</div>
									)}
										
										<div class="flex flex-wrap gap-1 mt-2">
											{item.tags?.slice(0, 3).map(tag => (
												<span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{tag.name}</span>
											))}
										</div>
									</div>
								</div>
								</div>
							);
						})}
					</div>
				) : (
					<div class="text-center py-12 text-red-500 dark:text-red-400">
						数据加载失败，请检查网络或稍后重试。
					</div>
				)}
			</div>
			<!-- 标签、“已看”、“想看”、“制作”等内容均在单页内显示 -->
		</div>
	</div>
</MainGridLayout>

<!-- 客户端交互 -->
<script is:inline>
  // 计算相对时间的函数
  function getRelativeTimeString(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);
    
    // 检查日期是否有效
    if (isNaN(date.getTime())) return '';
    
    // 根据时间差计算相对时间
    if (seconds < 60) {
      return `${seconds}秒前`;
    }
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes}分钟前`;
    }
    
    const hours = Math.floor(minutes / 60);
    if (hours < 24) {
      return `${hours}小时前`;
    }
    
    const days = Math.floor(hours / 24);
    if (days < 7) {
      return `${days}天前`;
    }
    
    const months = Math.floor(days / 30);
    if (months < 12) {
      return `${months}个月前`;
    }
    
    const years = Math.floor(days / 365);
    return `${years}年前`;
  }
  
  // 更新所有相对时间显示
  function updateRelativeTimes() {
    document.querySelectorAll('[data-update-time]').forEach(el => {
      const timestamp = el.getAttribute('data-update-time');
      if (timestamp) {
        el.textContent = getRelativeTimeString(timestamp);
      }
    });
  }
  
  // 初始化函数
  function initPage() {
    // 图片加载完成处理
    document.querySelectorAll('.bangumi-img').forEach(img => {
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        img.addEventListener('load', function() {
          this.classList.add('loaded');
        });
      }
    });

    // 图片错误处理
    document.querySelectorAll('img[data-src-fallback]').forEach(img => {
      img.addEventListener('error', function () {
        if (this.src !== this.dataset.srcFallback) {
          this.src = this.dataset.srcFallback;
          this.alt = '图片加载失败';
        }
      });
    });
    
    // 初始化相对时间显示
    updateRelativeTimes();
    
    // 每分钟更新一次相对时间
    setInterval(updateRelativeTimes, 60000);
  }

  // 页面加载完成后初始化
  document.addEventListener('DOMContentLoaded', initPage);
  
  // 监听Astro的页面导航事件（视图过渡）
  document.addEventListener('astro:after-swap', initPage);
  
  // 如果页面已经加载完成，直接初始化
  if (document.readyState === 'complete') {
    initPage();
  }
</script>

<style>
	.card-base {
		background: var(--card-bg);
		border: 1px solid var(--line-divider);
	}
	
	.line-clamp-2 {
		display: -webkit-box;
		-webkit-line-clamp: 2;
		-webkit-box-orient: vertical;
		overflow: hidden;
	}
	
	.animate-fade-in {
		animation: fadeIn 0.5s ease-in-out;
	}
	
	@keyframes fadeIn {
		from { opacity: 0; transform: translateY(10px); }
		to { opacity: 1; transform: translateY(0); }
	}

	/* 页面切换动画优化 */
	.bangumi-section {
		transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
	}
	
	.bangumi-section:not(.hidden) {
		opacity: 1;
		transform: translateY(0);
	}
	
	.bangumi-section.hidden {
		opacity: 0;
		transform: translateY(10px);
		pointer-events: none;
		height: 0;
		overflow: hidden;
	}
	
	.bangumi-content-container {
		min-height: 300px;
	}

	/* 图片加载动画优化 */
	.image-loading {
		position: relative;
		overflow: hidden;
		background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
		background-size: 200% 100%;
		animation: loadingShimmer 1.5s infinite;
		border-radius: 0.5rem;
	}

	@keyframes loadingShimmer {
		0% { background-position: -200% 0; }
		100% { background-position: 200% 0; }
	}

	/* 图片渐显效果 */
	.bangumi-img {
		transition: opacity 0.5s ease-in-out, transform 0.3s ease-in-out;
		opacity: 0;
		transform: scale(0.95);
	}

	.bangumi-img.loaded {
		opacity: 1;
		transform: scale(1);
	}

	/* 选项栏样式优化 */
	.tab-button {
		position: relative;
		border: none;
		background: none;
		cursor: pointer;
		transition: all 0.3s ease;
		margin-bottom: -1px;
		color: #666;
	}

	.tab-button:not([aria-selected="true"]) {
		color: #666;
	}

	@media (prefers-color-scheme: dark) {
		.tab-button:not([aria-selected="true"]) {
			color: #ccc;
		}
	}

	.tab-button:hover {
		color: var(--primary);
	}

	.tab-button[aria-selected="true"] {
		color: var(--primary);
		border-bottom: 2px solid var(--primary);
		font-weight: 600;
		background: linear-gradient(135deg, var(--primary) 0%, color-mix(in oklch, var(--primary), white 20%) 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
		text-shadow: 0 2px 4px color-mix(in oklch, var(--primary), transparent 80%);
	}

	.tab-button[aria-selected="true"]::after {
		content: '';
		position: absolute;
		bottom: -2px;
		left: 50%;
		transform: translateX(-50%);
		width: 20px;
		height: 3px;
		background: linear-gradient(90deg, var(--primary), color-mix(in oklch, var(--primary), white 30%));
		border-radius: 2px;
		box-shadow: 0 2px 8px color-mix(in oklch, var(--primary), transparent 70%);
		z-index: 1;
	}

	/* 进度条样式优化 */
	.progress-bar {
		transition: width 0.5s ease-in-out;
	}
</style>
