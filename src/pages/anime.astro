---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { siteConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// --- Bangumi API é…ç½® ---
const uid = "ferxal987";
const token = 'xQdjiPq4RSSym22QI92MVECwBHSFm5VV4Vpr9kdA';
const base = 'https://api.bgm.tv/v0';

// è¿™ä¸ªå‡½æ•°å·²è¢«fetchLatestEpisodeæ›¿ä»£

// --- ç±»å‹å®šä¹‰ ---
type Cat = 'watching' | 'wish' | 'collect';
type CatNum = 3 | 1 | 2;

interface Image {
  large?: string;
  common?: string;
  medium?: string;
  small?: string;
  grid?: string;
}

interface Subject {
  id: number;
  type: number;
  name: string;
  name_cn: string;
  eps?: number;
  images?: Image;
}

interface CollectionItem {
  subject_id: number;
  subject: Subject;
  ep_status: number;
  type: CatNum;
}

interface CollectionResponse {
  data: CollectionItem[];
  limit: number;
  offset: number;
  total: number;
}

const cats = [
  { key: 'watching', name: 'åœ¨çœ‹', type: 3 },
  { key: 'wish',     name: 'æƒ³çœ‹', type: 1 },
  { key: 'collect',  name: 'çœ‹å®Œ', type: 2 },
];

// --- æ•°æ®è·å– ---
async function fetchOnce(type: CatNum): Promise<CollectionItem[]> {
  try {
    const res = await fetch(
      `${base}/users/${uid}/collections?subject_type=2&type=${type}&limit=50`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`API Error (${type}):`, res.status, await res.text());
      return [];
    }

    const json: CollectionResponse = await res.json();
    return Array.isArray(json.data) ? json.data : [];
  } catch (err) {
    console.error('Fetch error:', err);
    return [];
  }
}

// è·å–å•ä¸ªç•ªå‰§çš„è¯¦ç»†ä¿¡æ¯
async function fetchSubjectDetails(id: number): Promise<any> {
  try {
    const res = await fetch(`${base}/subjects/${id}`, {
      headers: { Authorization: `Bearer ${token}` }
    });

    if (!res.ok) {
      console.error(`Subject API Error (${id}):`, res.status, await res.text());
      return null;
    }

    const data = await res.json();
    return data;
  } catch (err) {
    console.error('Subject fetch error:', err);
    return null;
  }
}

// è·å–ç•ªå‰§çš„æœ€æ–°æ›´æ–°é›†æ•°å’Œæ›´æ–°æ—¶é—´
async function fetchLatestEpisode(id: number, watched: number): Promise<{latestEp: number, updateTime: string}> {
  try {
    // æ ¹æ®å·²çœ‹é›†æ•°è®¡ç®—offsetï¼Œä½†ç¡®ä¿ä¸è¶…è¿‡APIé™åˆ¶
    // APIé”™è¯¯æ˜¾ç¤ºoffsetä¸èƒ½è¶…è¿‡10ï¼Œæ‰€ä»¥æˆ‘ä»¬é™åˆ¶æœ€å¤§å€¼ä¸º10
    const offset = Math.min(10, Math.max(0, watched - 1));
    const res = await fetch(
      `${base}/episodes?subject_id=${id}&type=0&limit=50&offset=${offset}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    if (!res.ok) {
      console.error(`Episodes API Error (${id}):`, res.status, await res.text());
      return { latestEp: 0, updateTime: '' };
    }

    const data = await res.json();
    if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
      return { latestEp: 0, updateTime: '' };
    }

    // æŸ¥æ‰¾æœ‰airdateä¸”æ—¥æœŸæœ€æ–°çš„ä¸€é›†
    const now = new Date();
    let latestEpisode = 0;
    let latestUpdateTime = '';
    
    for (const episode of data.data) {
      if (episode.airdate) {
        const airDate = new Date(episode.airdate);
        // åªè®¡ç®—å·²ç»æ’­å‡ºçš„é›†æ•°
        if (airDate <= now && episode.ep > latestEpisode) {
          latestEpisode = episode.ep;
          latestUpdateTime = episode.airdate; // ä¿å­˜æœ€æ–°æ›´æ–°æ—¶é—´
        }
      }
    }
    
    return { latestEp: latestEpisode, updateTime: latestUpdateTime };
  } catch (err) {
    console.error('Episodes fetch error:', err);
    return { latestEp: 0, updateTime: '' };
  }
}

let allDataFetched = true;
const data: Record<Cat, CollectionItem[]> = { watching: [], wish: [], collect: [] };

try {
  const results = await Promise.all(cats.map(({ type }) => fetchOnce(type)));
  cats.forEach(({ key }, i) => { data[key] = results[i]; });
  
  // å¹¶è¡Œè·å–æ‰€æœ‰ç•ªå‰§çš„è¯¦ç»†ä¿¡æ¯
      const allItems = cats.flatMap(cat => 
        data[cat.key].map(item => ({ item, category: cat.key }))
      );
      
      const detailedItems = await Promise.all(
        allItems.map(async ({ item, category }) => {
          const details = await fetchSubjectDetails(item.subject.id);
          let latestEpisode = 0;
          let updateTime = '';
          
          // è·å–æ‰€æœ‰ç•ªå‰§çš„æœ€æ–°æ›´æ–°é›†æ•°å’Œæ›´æ–°æ—¶é—´
          const { latestEp, updateTime: latestUpdateTime } = await fetchLatestEpisode(item.subject.id, item.ep_status || 0);
          latestEpisode = latestEp;
          updateTime = latestUpdateTime;
          
          if (details) {
            // ä¿ç•™åŸå§‹çš„ type å­—æ®µï¼ˆæ”¶è—çŠ¶æ€ï¼‰ï¼Œåªåˆå¹¶å…¶ä»–è¯¦ç»†ä¿¡æ¯
            const { type, ...restDetails } = details;
            return { 
              category,
              index: data[category].indexOf(item),
              updatedItem: { 
                ...item, 
                ...restDetails,
                latest_episode: latestEpisode, // æ·»åŠ æœ€æ–°æ›´æ–°é›†æ•°ä¿¡æ¯
                update_time: updateTime // æ·»åŠ æœ€æ–°æ›´æ–°æ—¶é—´
              }
            };
          }
          return null;
        })
      );
      
      // æ›´æ–°æ•°æ®
      detailedItems.filter(Boolean).forEach(({ category, index, updatedItem }) => {
        data[category][index] = updatedItem;
      });
} catch (err) {
  console.error("Fetch failed:", err);
  allDataFetched = false;
}

// å®šä¹‰é™æ€å‰¯æ ‡é¢˜æ•°ç»„
const subtitles = [

];

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬
function getStatusText(status: string): string {
	switch (status) {
		case "watching":
			return i18n(I18nKey.animeStatusWatching);
		case "completed":
			return i18n(I18nKey.animeStatusCompleted);
		default:
			return status;
	}
}

// å›¾ç‰‡å¤„ç†å‡½æ•° - è½¬æ¢ä¸ºwebpå¹¶è°ƒæ•´å°ºå¯¸
function processImageUrl(url: string): string {
  if (!url || url.includes('/default-image.png')) return url;
  
  // ä¿®æ”¹æºå›¾åƒURLï¼Œæ·»åŠ /r/400/å‰ç¼€ä»¥å‡å°å›¾ç‰‡å°ºå¯¸
  const modifiedUrl = url.replace('https://lain.bgm.tv/', 'https://lain.bgm.tv/r/400/');
  
  // ä½¿ç”¨å›¾ç‰‡CDNæœåŠ¡è½¬æ¢ä¸ºWebPæ ¼å¼å¹¶è°ƒæ•´å°ºå¯¸
  return `https://proxy.chenhen.top/https://images.weserv.nl/?url=${encodeURIComponent(modifiedUrl)}&w=300&h=400&output=webp`;
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(type: number) {
	switch (type) {
		case 3: // watching
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100/[var(--status-watching-opacity)] text-green-700 dark:bg-green-900/[var(--status-watching-opacity)] dark:text-green-300 border border-green-700/[var(--status-border-opacity)] dark:border-green-300/[var(--status-border-opacity)]",

				icon: "â–¶",
			};
		case 2: // collect
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100/[var(--status-completed-opacity)] text-blue-700 dark:bg-blue-900/[var(--status-completed-opacity)] dark:text-blue-300 border border-blue-700/[var(--status-border-opacity)] dark:border-blue-300/[var(--status-border-opacity)]",

				icon: "âœ“",
			};
		case 1: // wish
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100/[var(--status-planned-opacity)] text-amber-700 dark:bg-amber-900/[var(--status-planned-opacity)] dark:text-amber-300 border border-amber-700/[var(--status-border-opacity)] dark:border-amber-300/[var(--status-border-opacity)]",

				icon: "â°",
			};
		default:
			return {
				text: "Unknown",
				class: "bg-gray-100/[var(--status-planned-opacity)] text-gray-700 dark:bg-gray-800/[var(--status-planned-opacity)] dark:text-gray-300 border border-gray-700/[var(--status-border-opacity)] dark:border-gray-300/[var(--status-border-opacity)]",

				icon: "?",
			};
	}
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
const stats = {
	total: data.watching.length + data.wish.length + data.collect.length,
	watching: data.watching.length,
	completed: data.collect.length
};
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
	<style is:global>
		:root {
			--status-planned-opacity: 0.3;
			--status-completed-opacity: 0.3;
			--status-watching-opacity: 0.3;
			--status-border-opacity: 0.15;
		}
	</style>
	<div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
		<div class="card-base z-10 px-9 py-6 relative w-full">
			<!-- é¡µé¢æ ‡é¢˜ -->
			<div class="relative w-full mb-8">
				<div class="mb-6">
					<h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2">{i18n(I18nKey.animeTitle)}</h1>
					<p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
				</div>
				
				<!-- ç»Ÿè®¡å¡ç‰‡ -->
				<div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-8">
					<div class="bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">ğŸ“Š</div>
							<div>
								<div class="text-2xl font-bold text-blue-600 dark:text-blue-400">{stats.total}</div>
								<div class="text-sm text-blue-600/70 dark:text-blue-400/70">{i18n(I18nKey.animeTotal)}</div>
							</div>
						</div>
					</div>
					<div class="bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900/20 dark:to-green-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">â–¶ï¸</div>
							<div>
								<div class="text-2xl font-bold text-green-600 dark:text-green-400">{stats.watching}</div>
								<div class="text-sm text-green-600/70 dark:text-green-400/70">{i18n(I18nKey.animeWatching)}</div>
							</div>
						</div>
					</div>
					<div class="bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 rounded-lg p-4">
						<div class="flex items-center gap-3">
							<div class="text-2xl">âœ…</div>
							<div>
								<div class="text-2xl font-bold text-purple-600 dark:text-purple-400">{stats.completed}</div>
								<div class="text-sm text-purple-600/70 dark:text-purple-400/70">{i18n(I18nKey.animeCompleted)}</div>
							</div>
						</div>
					</div>
					
				</div>
			</div>

			<!-- åŠ¨æ¼«åˆ—è¡¨ -->
				<div class="mb-8">
				<h2 class="text-2xl font-bold text-black/90 dark:text-white/90 mb-4">
					{i18n(I18nKey.animeList)}
				</h2>
				{allDataFetched ? (
				<div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
					{[...data.watching, ...data.wish, ...data.collect].map((item, index) => {
							const s = item.subject || item;
							const total = s.eps || 0;
							const watched = item.ep_status || 0;
							const percent = total ? Math.min(100, Math.round((watched / total) * 100)) : 0;
							const img = processImageUrl(s.images?.large || s.images?.common || '/default-image.png');
							const statusInfo = getStatusInfo(item.type);
							
							return (
								<div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]">
									<!-- å°é¢åŒºåŸŸ - ç«–å±æ¯”ä¾‹ -->
									<div class="relative aspect-[2/3] overflow-hidden">
										<a href={`https://bgm.tv/subject/${s.id}`} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
											<ImageWrapper 
												src={img}
												alt={s.name_cn || s.name || 'æœªçŸ¥'}
												class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
												data-src-fallback="/default-image.png"
												id={`anime-img-${s.id}`}
											/>
											<!-- æ‚¬åœæ•ˆæœå·²ç§»é™¤ï¼Œä»…ä¿ç•™é“¾æ¥åŠŸèƒ½ -->
										</a>
										
										<!-- çŠ¶æ€æ ‡ç­¾ -->
										<div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
											<span class="mr-1">{statusInfo.icon}</span>
											<span>{statusInfo.text}</span>
										</div>
										
										<!-- è¯„åˆ† -->
										<div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
											<svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
												<path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
											</svg>
											<span>{s.rating?.score || s.score || '0.0'}</span>
										</div>
										
										<!-- è¿›åº¦æ¡ - åœ¨å°é¢åº•éƒ¨ -->
										{item.type === 3 && (
											<div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
												<div class="w-full bg-white/20 rounded-full h-1.5 mb-1 relative">
													{/* å·²æ›´æ–°è¿›åº¦æ¡ */}
													{item.latest_episode > 0 && (
														<div class="bg-gradient-to-r from-amber-400 to-orange-400 h-1.5 rounded-full absolute top-0 left-0 transition-all duration-300" 
															style={`width: ${Math.min(100, Math.round((item.latest_episode / total) * 100))}%`}>
														</div>
													)}
													{/* å·²çœ‹è¿›åº¦æ¡ */}
													<div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300 relative z-10" 
														style={`width: ${percent}%`}>
													</div>
												</div>
												<div class="text-white text-xs font-medium flex justify-between">
													<span>{watched}/{total} ({Math.round(percent)}%)</span>
													{item.latest_episode > watched && (
														<span class="text-amber-300">å·²æ›´æ–°è‡³: ç¬¬{item.latest_episode}é›†</span>
													)}
												</div>
											</div>
										)}
									</div>
									
									<!-- å†…å®¹åŒºåŸŸ - ç´§å‡‘è®¾è®¡ -->
									<div class="p-3">
										<h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{s.name_cn || s.name}</h3>
										
										{/* æ›´æ–°çŠ¶æ€ä¿¡æ¯ */}
										{item.type === 3 && item.latest_episode > 0 && (
											<p class="text-xs mb-2">
												{item.latest_episode > item.ep_status ? (
													<span class="text-amber-500 dark:text-amber-400 font-medium">ğŸ”” æœªçœ‹ {item.latest_episode - item.ep_status} é›†</span>
												) : (
													<span class="text-green-500 dark:text-green-400 font-medium">âœ“ å·²çœ‹æœ€æ–°</span>
												)}
											</p>
										)}
										
										<p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{subtitles[index % subtitles.length]}</p>
									
									<!-- è¯¦ç»†ä¿¡æ¯ - æ›´ç´§å‡‘ -->
									<div class="space-y-1 text-xs">
										<div class="flex justify-between">
											<span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
											<span class="text-black/70 dark:text-white/70">{s.date}</span>
										</div>
										
										{/* æœ€è¿‘æ›´æ–°æ—¶é—´ */}
									{item.update_time && (
										<div class="flex justify-between">
											<span class="text-black/50 dark:text-white/50">æœ€è¿‘æ›´æ–°</span>
											<span class="text-black/70 dark:text-white/70" data-update-time={item.update_time}></span>
										</div>
									)}
										
										<div class="flex flex-wrap gap-1 mt-2">
											{item.tags?.slice(0, 3).map(tag => (
												<span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{tag.name}</span>
											))}
										</div>
									</div>
								</div>
								</div>
							);
						})}
					</div>
				) : (
					<div class="text-center py-12 text-red-500 dark:text-red-400">
						æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•ã€‚
					</div>
				)}
			</div>
			<!-- æ ‡ç­¾ã€â€œå·²çœ‹â€ã€â€œæƒ³çœ‹â€ã€â€œåˆ¶ä½œâ€ç­‰å†…å®¹å‡åœ¨å•é¡µå†…æ˜¾ç¤º -->
		</div>
	</div>
</MainGridLayout>

<!-- å®¢æˆ·ç«¯äº¤äº’ -->
<script is:inline>
  // è®¡ç®—ç›¸å¯¹æ—¶é—´çš„å‡½æ•°
  function getRelativeTimeString(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);
    
    // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆ
    if (isNaN(date.getTime())) return '';
    
    // æ ¹æ®æ—¶é—´å·®è®¡ç®—ç›¸å¯¹æ—¶é—´
    if (seconds < 60) {
      return `${seconds}ç§’å‰`;
    }
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes}åˆ†é’Ÿå‰`;
    }
    
    const hours = Math.floor(minutes / 60);
    if (hours < 24) {
      return `${hours}å°æ—¶å‰`;
    }
    
    const days = Math.floor(hours / 24);
    if (days < 7) {
      return `${days}å¤©å‰`;
    }
    
    const months = Math.floor(days / 30);
    if (months < 12) {
      return `${months}ä¸ªæœˆå‰`;
    }
    
    const years = Math.floor(days / 365);
    return `${years}å¹´å‰`;
  }
  
  // æ›´æ–°æ‰€æœ‰ç›¸å¯¹æ—¶é—´æ˜¾ç¤º
  function updateRelativeTimes() {
    document.querySelectorAll('[data-update-time]').forEach(el => {
      const timestamp = el.getAttribute('data-update-time');
      if (timestamp) {
        el.textContent = getRelativeTimeString(timestamp);
      }
    });
  }
  
  // åˆå§‹åŒ–å‡½æ•°
  function initPage() {
    // å›¾ç‰‡åŠ è½½å®Œæˆå¤„ç†
    document.querySelectorAll('.bangumi-img').forEach(img => {
      if (img.complete) {
        img.classList.add('loaded');
      } else {
        img.addEventListener('load', function() {
          this.classList.add('loaded');
        });
      }
    });

    // å›¾ç‰‡é”™è¯¯å¤„ç†
    document.querySelectorAll('img[data-src-fallback]').forEach(img => {
      img.addEventListener('error', function () {
        if (this.src !== this.dataset.srcFallback) {
          this.src = this.dataset.srcFallback;
          this.alt = 'å›¾ç‰‡åŠ è½½å¤±è´¥';
        }
      });
    });
    
    // åˆå§‹åŒ–ç›¸å¯¹æ—¶é—´æ˜¾ç¤º
    updateRelativeTimes();
    
    // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡ç›¸å¯¹æ—¶é—´
    setInterval(updateRelativeTimes, 60000);
  }

  // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
  document.addEventListener('DOMContentLoaded', initPage);
  
  // ç›‘å¬Astroçš„é¡µé¢å¯¼èˆªäº‹ä»¶ï¼ˆè§†å›¾è¿‡æ¸¡ï¼‰
  document.addEventListener('astro:after-swap', initPage);
  
  // å¦‚æœé¡µé¢å·²ç»åŠ è½½å®Œæˆï¼Œç›´æ¥åˆå§‹åŒ–
  if (document.readyState === 'complete') {
    initPage();
  }
</script>

<style>
	.card-base {
		background: var(--card-bg);
		border: 1px solid var(--line-divider);
	}
	
	.line-clamp-2 {
		display: -webkit-box;
		-webkit-line-clamp: 2;
		-webkit-box-orient: vertical;
		overflow: hidden;
	}
	
	.animate-fade-in {
		animation: fadeIn 0.5s ease-in-out;
	}
	
	@keyframes fadeIn {
		from { opacity: 0; transform: translateY(10px); }
		to { opacity: 1; transform: translateY(0); }
	}

	/* é¡µé¢åˆ‡æ¢åŠ¨ç”»ä¼˜åŒ– */
	.bangumi-section {
		transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
	}
	
	.bangumi-section:not(.hidden) {
		opacity: 1;
		transform: translateY(0);
	}
	
	.bangumi-section.hidden {
		opacity: 0;
		transform: translateY(10px);
		pointer-events: none;
		height: 0;
		overflow: hidden;
	}
	
	.bangumi-content-container {
		min-height: 300px;
	}

	/* å›¾ç‰‡åŠ è½½åŠ¨ç”»ä¼˜åŒ– */
	.image-loading {
		position: relative;
		overflow: hidden;
		background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
		background-size: 200% 100%;
		animation: loadingShimmer 1.5s infinite;
		border-radius: 0.5rem;
	}

	@keyframes loadingShimmer {
		0% { background-position: -200% 0; }
		100% { background-position: 200% 0; }
	}

	/* å›¾ç‰‡æ¸æ˜¾æ•ˆæœ */
	.bangumi-img {
		transition: opacity 0.5s ease-in-out, transform 0.3s ease-in-out;
		opacity: 0;
		transform: scale(0.95);
	}

	.bangumi-img.loaded {
		opacity: 1;
		transform: scale(1);
	}

	/* é€‰é¡¹æ æ ·å¼ä¼˜åŒ– */
	.tab-button {
		position: relative;
		border: none;
		background: none;
		cursor: pointer;
		transition: all 0.3s ease;
		margin-bottom: -1px;
		color: #666;
	}

	.tab-button:not([aria-selected="true"]) {
		color: #666;
	}

	@media (prefers-color-scheme: dark) {
		.tab-button:not([aria-selected="true"]) {
			color: #ccc;
		}
	}

	.tab-button:hover {
		color: var(--primary);
	}

	.tab-button[aria-selected="true"] {
		color: var(--primary);
		border-bottom: 2px solid var(--primary);
		font-weight: 600;
		background: linear-gradient(135deg, var(--primary) 0%, color-mix(in oklch, var(--primary), white 20%) 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
		text-shadow: 0 2px 4px color-mix(in oklch, var(--primary), transparent 80%);
	}

	.tab-button[aria-selected="true"]::after {
		content: '';
		position: absolute;
		bottom: -2px;
		left: 50%;
		transform: translateX(-50%);
		width: 20px;
		height: 3px;
		background: linear-gradient(90deg, var(--primary), color-mix(in oklch, var(--primary), white 30%));
		border-radius: 2px;
		box-shadow: 0 2px 8px color-mix(in oklch, var(--primary), transparent 70%);
		z-index: 1;
	}

	/* è¿›åº¦æ¡æ ·å¼ä¼˜åŒ– */
	.progress-bar {
		transition: width 0.5s ease-in-out;
	}
</style>
